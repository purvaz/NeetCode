package main

func main() {

	// fmt.Println(Arrayshashing.FindDuplicates([]int{4, 3, 2, 7, 8, 2, 3, 1}))

	// nums := []int{2, 7, 11, 15}
	// fmt.Println(Arrayshashing.ContainsDuplicate(nums))

	// fmt.Println(Arrayshashing.IsAnagram("anagram", "nagaram"))

	// fmt.Println(Arrayshashing.TwoSum(nums, 9))

	// strs := []string{"eat", "tea", "tan", "ate", "nat", "bat"}
	// fmt.Println(Arrayshashing.GroupAnagrams(strs))

	// nums := []int{1, 2}
	// fmt.Println(Arrayshashing.TopKFrequent(nums, 2))

	// nums := []int{1, 2, 3, 4}
	// fmt.Println(Arrayshashing.ProductExceptSelf(nums))

	// nums := []int{0, 3, 7, 2, 5, 8, 4, 6, 0, 1}
	// fmt.Println(Arrayshashing.LongestConsecutive(nums))

	// board := [][]byte{{'5', '3', '.', '.', '7', '.', '.', '.', '.'},
	// 	{'6', '.', '.', '1', '9', '5', '.', '.', '.'},
	// 	{'.', '9', '8', '.', '.', '.', '.', '6', '.'},
	// 	{'8', '.', '.', '.', '6', '.', '.', '.', '3'},
	// 	{'4', '.', '.', '8', '.', '3', '.', '.', '1'},
	// 	{'7', '.', '.', '.', '2', '.', '.', '.', '6'},
	// 	{'.', '6', '.', '.', '.', '.', '2', '8', '.'},
	// 	{'.', '.', '.', '4', '1', '9', '.', '.', '5'},
	// 	{'.', '.', '.', '.', '8', '.', '.', '7', '9'}}

	// fmt.Println(Arrayshashing.IsValidSudoku(board))

	// fmt.Println(Stack.IsValid("]"))

	// obj := Stack.Constructor()
	// obj.Push(3)
	// obj.Push(2)
	// fmt.Println("Top : ", obj.Top())
	// fmt.Println("Minimum : ", obj.GetMin())
	// obj.Pop()
	// fmt.Println("Minimum : ", obj.GetMin())
	// fmt.Println("Top : ", obj.Top())

	// tokens := []string{"4", "13", "5", "/", "+"}
	// fmt.Println(Stack.EvalRPN(tokens))

	// fmt.Println(Stack.GenerateParenthesis(2))

	// temperatures := []int{73, 74, 75, 71, 69, 72, 76, 73}
	// fmt.Println(Stack.DailyTemperatures(temperatures))

	// position := []int{6, 8}
	// speed := []int{3, 2}
	// fmt.Println(Stack.CarFleet(10, position, speed))

	// heights := []int{2, 4}
	// fmt.Println(Stack.LargestRectangleArea(heights))

	// fmt.Println(TwoPointers.IsPalindrome(" "))

	// nums := []int{-1, 0}
	// fmt.Println(TwoPointers.TwoSum(nums, -1))

	// nums := []int{-1, 0, 1, 2, -1, -4}
	// fmt.Println(TwoPointers.ThreeSum(nums))

	// height := []int{1, 1}
	// fmt.Println(TwoPointers.MaxArea(height))

	// height := []int{5, 5, 1, 7, 1, 1, 5, 2, 7, 6}
	// fmt.Println(TwoPointers.Trap(height))

	// prices := []int{1, 2, 4, 2, 5, 7, 2, 4, 9, 0, 9}
	// fmt.Println(SlidingWindow.MaxProfit(prices))

	// fmt.Println(SlidingWindow.LengthOfLongestSubstring("abcabcbb"))

	// fmt.Println(SlidingWindow.CharacterReplacement("ABABBA", 2))

	// fmt.Println(SlidingWindow.CheckInclusion("adc", "dcda"))

	// nums := []int{1, 3, -1, -3, 5, 3, 6, 7}
	// fmt.Println(SlidingWindow.MaxSlidingWindow(nums, 3))

	// fmt.Println(SlidingWindow.MinWindow("AA", "AA"))

	// head := LinkedLists.CreateLinkedList()
	// LinkedLists.ReverseList(head)

	// nums1 := []int{1, 2, 4}
	// list1 := LinkedLists.CreateLinkedList(nums1)
	// nums2 := []int{1, 3, 4}
	// list2 := LinkedLists.CreateLinkedList(nums2)
	// LinkedLists.MergeTwoLists(list1, list2)

	// nums := []int{1, 2, 3, 4, 5}
	// LinkedLists.ReorderList(LinkedLists.CreateLinkedList(nums))

	// nums := []int{1, 2}
	// LinkedLists.RemoveNthFromEnd(LinkedLists.CreateLinkedList(nums), 2)

	// LinkedLists.CopyRandomList(LinkedLists.CreateRandomList())

	// nums1 := []int{9, 9, 9, 9, 9, 9, 9}
	// list1 := LinkedLists.CreateLinkedList(nums1)
	// nums2 := []int{9, 9, 9, 9}
	// list2 := LinkedLists.CreateLinkedList(nums2)
	// LinkedLists.AddTwoNumbers(list1, list2)

	// nums := []int{1, 3, 4, 2, 2}
	// fmt.Println(LinkedLists.FindDuplicate(nums))

	// obj := LinkedLists.Constructor(2)
	// obj.Put(1, 1)
	// obj.Put(2, 2)
	// fmt.Println(obj.Get(1))
	// obj.Put(3, 3)
	// fmt.Println(obj.Get(2))
	// obj.Put(4, 4)
	// fmt.Println(obj.Get(1))
	// fmt.Println(obj.Get(3))
	// fmt.Println(obj.Get(4))

	// obj := LinkedLists.Constructor(1)
	// obj.Put(2, 1)
	// fmt.Println(obj.Get(2))
	// obj.Put(3, 2)
	// fmt.Println(obj.Get(2))
	// fmt.Println(obj.Get(3))

	// list1 := LinkedLists.CreateLinkedList([]int{1, 4, 5})
	// list2 := LinkedLists.CreateLinkedList([]int{1, 3, 4})
	// list3 := LinkedLists.CreateLinkedList([]int{2, 6})
	// LinkedLists.MergeKLists([]*LinkedLists.ListNode{list1, list2, list3})

	// LinkedLists.ReverseKGroup(LinkedLists.CreateLinkedList([]int{1, 2, 3, 4, 5}), 2)

	// fmt.Println(BinarySearch.Search([]int{-1, 0, 3, 5, 9, 12}, 12))

	// fmt.Println(BinarySearch.SearchMatrix([][]int{{1}, {3}, {5}}, 3))

	// fmt.Println(BinarySearch.MinEatingSpeed([]int{30, 11, 23, 4, 20}, 5))

	// fmt.Println(BinarySearch.FindMin([]int{2, 1}))

	// fmt.Println(BinarySearch.Search([]int{3, 1}, 1))

	// timeMap := BinarySearch.Constructor()
	// timeMap.Set("foo", "bar", 1)                     // store the key "foo" and value "bar" along with timestamp = 1.
	// fmt.Println("Getting : ", timeMap.Get("foo", 1)) // return "bar"
	// fmt.Println("Getting : ", timeMap.Get("foo", 3)) // return "bar", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is "bar".
	// timeMap.Set("foo", "bar2", 4)                    // store the key "foo" and value "bar2" along with timestamp = 4.
	// fmt.Println("Getting : ", timeMap.Get("foo", 4)) // return "bar2"
	// fmt.Println("Getting : ", timeMap.Get("foo", 5)) // return "bar2"

	// fmt.Println(BinarySearch.FindMedianSortedArrays([]int{100001}, []int{100000}))

	// Trees.TraverseTree(Trees.CreateTree())

	// fmt.Println(Trees.LowestCommonAncestor(Trees.CreateBSTree(), &Trees.TreeNode{Val: 2}, &Trees.TreeNode{Val: 8}).Val)

	// fmt.Println(Trees.LevelOrder(Trees.CreateTree()))

	// fmt.Println(Trees.RightSideView(Trees.CreateBSTree()))

	// fmt.Println(Heaps.LastStoneWeight([]int{2, 2}))

	// fmt.Println(Heaps.KClosest([][]int{{3, 3}, {5, -1}, {-2, 4}}, 2))

	// fmt.Println(Heaps.FindKthLargest([]int{3, 2, 3, 1, 2, 4, 5, 5, 6}, 4))

	// fmt.Println(Heaps.LeastInterval([]byte{'A', 'A', 'A', 'B', 'B', 'B'}, 2))

	// fmt.Println(Backtracking.Subsets([]int{1, 2, 3}))

	// fmt.Println(Backtracking.CombinationSum([]int{2, 3, 6, 7}, 7))

	// fmt.Println(Backtracking.Permute([]int{1, 2, 3}))

	// fmt.Println(Backtracking.SubsetsWithDup([]int{3, 2, 2, 1}))

	// fmt.Println(Backtracking.Exist([][]byte{{'A', 'B', 'C', 'E'}, {'S', 'F', 'C', 'S'}, {'A', 'D', 'E', 'E'}}, "ABCCED"))

	// fmt.Println(Backtracking.Partition("aab"))

	// fmt.Println(DynamicProgramming.MinCostClimbingStairs([]int{10, 15, 20}))

	// fileSystem := Tries.Constructor()
	// fmt.Println(fileSystem.CreatePath("/leet", 1))      // return true
	// fmt.Println(fileSystem.CreatePath("/leet/code", 2)) // return true
	// fmt.Println(fileSystem.Get("/leet/code"))           // return 2
	// fmt.Println(fileSystem.CreatePath("/c/d", 1))       // return false because the parent path "/c" doesn't exist.
	// fmt.Println(fileSystem.Get("/c"))                   // return -1 because this path doesn't exist.

	// strs := []string{"hello", "world"}
	// probs := []float64{0.7, 0.3}

	// Numbers.CallWeigtedStrings(strs, probs, 100)

	// // Call the function multiple times to see the distribution
	// counts := map[string]int{}
	// for i := 0; i < 100; i++ {
	// 	result := Numbers.WeightedRandom(strs, probs)
	// 	counts[result]++
	// }

	// // Print the results
	// for str, count := range counts {
	// 	fmt.Printf("%s: %d\n", str, count)
	// }

	// word := "hello world"

	// movements := Arrayshashing.CalculateKeyMovements(word)
	// fmt.Println("Key Movements for '", word, "':")
	// for _, movement := range movements {
	// 	fmt.Printf("From: (%d, %d) To: (%d, %d) Cost: %d\n", movement.From.X, movement.From.Y, movement.To.X, movement.To.Y, movement.Cost)
	// }

	// fmt.Println(Arrayshashing.CalculateKeyStrokes(word))

	// fmt.Println(Numbers.Solve(70, 80, 90, 10))
	// fmt.Println(Numbers.Solve(100, 120, 60, 19))
	// fmt.Println(Numbers.Solve(150, 70, 70, 10))
	// fmt.Println(Numbers.Solve(120, 100, 100, 10))
	// fmt.Println(Numbers.Solve(90, 90, 118, 10))
	// fmt.Println(Numbers.Solve(120, 100, 110, 20))
	// fmt.Println(Numbers.Solve(80, 110, 80, 70))
	// fmt.Println(Numbers.Solve(70, 80, 90, 10))
	// fmt.Println(Numbers.Solve(100, 150, 60, 30))

	// fmt.Println(DynamicProgramming.NumDecodings("226"))

	// fmt.Println(DynamicProgramming.CoinChange([]int{1, 3, 4, 5}, 7))

	// fmt.Println(DynamicProgramming.MaxProduct([]int{2, 3, -2, 4}))

	// fmt.Println(DynamicProgramming.WordBreak("catsandog", []string{"cats", "dog", "sand", "and", "cat"}))

	// fmt.Println(DynamicProgramming.LengthOfLIS([]int{1, 2, 4, 3}))

	// fmt.Println(DynamicProgramming.CanPartition([]int{1, 11, 5, 5, 5, 2, 3}))

	// fmt.Println(DynamicProgramming2D.UniquePaths(3, 2))

	// fmt.Println(DynamicProgramming2D.LongestCommonSubsequence("abcde", "ace"))

	// fmt.Println(DynamicProgramming2D.MaxProfit([]int{1, 2, 3, 0, 2}))

	// fmt.Println(Graphs.NumIslands([][]byte{{'1', '1', '1', '1', '0'}, {'1', '1', '0', '1', '0'}, {'1', '1', '0', '0', '0'}, {'0', '0', '0', '0', '0'}}))

	// fmt.Println(Graphs.MaxAreaOfIsland([][]int{{0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0}, {0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0}, {0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0}}))

	// fmt.Println(Graphs.MaxAreaOfIsland([][]int{{0, 0, 0, 0, 0, 0, 0, 0}}))

}
